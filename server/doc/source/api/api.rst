Основные API методы
===================

Все методы API представлены в файле ``/server/src/api.py``.
Все API сетоды возвращают словарь, в котором содержится как минимум статус операции. Статус имеет следующую структуру:

.. code-block:: python

    {
        'type': 'OK' or 'Error'
        'error_type': 'OptionError' or 'ValueError'
        'message': '%STR%'
    }

Наличие поля ``type`` гарантируется. По значению этого поля можно определить завершился ли запрос на сервер успешно.
Если значение поля ``OK``, то запрос завершился корректно. В противном случае значение поля будет ``Error``.
Если запрос совершился с ошибкой, то все остальные поля кроме статуса будут содержать значение ``NONE``.
Остальные два поля являются опциональными. Оба поля присутствуют в словаре статуса только в том случае, если
запрос завершился с ошибкой. Поле ``error_type`` содержит в себе тип ошибки. Значение ``OptionError`` сигнализирует
о том, что в переданных параметрах была допущена ошибка, например было передано неверное название опции. Значение
``ValueError`` сигнализирует о том, у одно из параметров неверное значение, например для *id* пользователя имеет
значение ``-1``. Поле ``message`` содержит сообщение с подробным описанием возникшей проблемы.

api_get_article()
^^^^^^^^^^^^^^^^^

Метод для получения статьи.

.. code-block:: python

    @app.route('/article', methods=['GET'])
    def api_get_article()
    """
    :headers: 'article-id' - str(int)

    :returns: str(json) in format {'status': %JSON%, 'article': %JSON%}
    """

Этот метод обрабатывает только один заголовок - *id* статьи, которую нужно вернуть.
Метод читает все необходимые данные о статье с требуемым *id* и возвращает статью в формате *json*.
Статья имеет следующую структуру:

.. code-block:: python

    {
        'article': '%JSON%' # user-defined article structure
        'preview_content': '%JSON%' # user-defined preview structure
        'name': '%STR%'
        'author_preview': {
                            'name': '%STR%'
                            'page': '%STR%'
                            'avatar': '%STR%'
                          }
        'answers': [
                        '%COMMENT_ID%': {
                                            'comment_text': '%STR%'
                                            'author_id': '%INT%'
                                            'likes_count': '%INT%'
                                            'id': '%INT%'
                                            'answers': '%LIST%'
                        },
                        'ANOTHER_COMMENT_ID': {
                        },
                        ...
                    ]
        'likes_count': '%INT%'
        'likes_id': '%STR%'
        'comments_count': '%INT%'
        'tags': '%STR%'
        'created': '%STR%'
    }

Ключ ``article`` содержит тело статьи со структурой определенной пользователем.
Сервер никак не изменяет статью, которую ему передали, и не обращается к ее содержимому.
Поэтому вся структура сохраняется в неизменном виде. Это позволяет определить структуру статьи на строрне *frontend* и
изменять ее без необходимости вносить изменения на сервер.

Ключ ``preview_content`` содержит *json* с контентом, который требуется для предпоказа в ленте.
Сервер никак не изменяет структуру и не обращается к ее содержимому.
Это позволяет определить структуру контента для предпоказа на строрне *frontend* и
изменять ее без необходимости вносить изменения на сервер.

Ключ ``name`` содержит название статьи.

Ключ ``author_preview`` содержит *json* с данными об авторе для предпоказа. Данные об авторе содержат *login*
пользователя, доступный по ключу ``name``, ссылку на страницу автора, доступную по ключу ``page`` и ссылку на аватар
автора, доступную по ключу ``avatar``.

Ключ ``answers`` содержит список коментариев и ответов к ним.
Этот список содержит древовиднусюб структуру комментариев.
В списке первого уровня лежат комментарии, которые пользователи написали к статье.
У каждого комментария есть список ответов, в котором содержаться комментарии с такой же структурой.
Для каждого комментария определены ключи ``comment_text``, который соджержит текст комментария, ``author_id``,
который содержит значение *id* автора комментария, ``likes_count``, котоырый содержит количество лайков
на комментарии, ``id``, который содержит *id* комментария и ``answers``, который содержит список ответов
на комментарий.

Ключ ``likes_count`` содержит количество лайков статьи. Ключ ``comments_count`` содержит количество комментариев статьи.

Ключ ``likes_id`` содержит *id* пользователей, который лайкнули статью, перечисленные через разделитель ``~``.
Напирмер, статья имеющая лайки от пользователей с *id* ``1`` и ``2`` будет иметь значение по ключу ``likes_id``:
``~1~~2~``.

Ключ ``tags`` содержит теги статьи, перечисленные через разделитель ``~``. Напирмер, статья имеющая теги ``Обзор``,
``Call of Duty`` и ``Лонг`` будет иметь значение по ключу ``tags``: ``~Обзор~~Call of duty~~Лонг~``.

Ключ ``created`` содержит дату публикации статьи в строковом формате.


api_get_article_likes_comments()
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод для получения количества лайков и количества комментариев у статьи.

.. code-block:: python

    @app.route('/article/likes_comments', methods=['GET'])
    def api_get_article_likes_comments()
    """
    :headers: 'article-id' - str(int)

    :returns: str(json) in format {'status': %JSON%, 'likes-count': %INT%, 'comments-count': %INT%}
    """

Этот метод обрабатывает только один заголовок - *id* статьи,
для которой нужно узнать количество комментариев и лайков.

api_post_article()
^^^^^^^^^^^^^^^^^^

Метод для опубликования статьи.

.. code-block:: python

    @app.route('/article', methods=['POST'])
    def api_post_article()
    """
    :headers: 'article' - str(json)
              'user-id' - str(int)

    :returns: str(json) in format {'status': %JSON%, 'article-id': %INT%}
    """

Заголовок ``article`` является *json* объектом в строковом формате, который представляет собой статью.

Статья обязана имееть следующую структуру:

.. code-block:: python

    {
        'article': '%JSON%' # user-defined article structure
        'preview_content': '%JSON%' # user-defined preview structure
        'name': '%STR%'
        'tags': '%STR%'
        'created': '%STR%'
    }

Ключ ``article`` содержит тело статьи со структурой определенной пользователем.
Сервер никак не изменяет статью, которую ему передали, и не обращается к ее содержимому.
Поэтому вся структура сохраняется в неизменном виде. Это позволяет определить структуру статьи на строрне *frontend* и
изменять ее без необходимости вносить изменения на сервер.

Ключ ``preview_content`` содержит *json* с контентом, который требуется для предпоказа в ленте.
Сервер никак не изменяет структуру и не обращается к ее содержимому.
Это позволяет определить структуру контента для предпоказа на строрне *frontend* и
изменять ее без необходимости вносить изменения на сервер.

Ключ ``name`` содержит название статьи.

Ключ ``tags`` содержит теги статьи, перечисленные через разделитель ``~``. Напирмер, статья имеющая теги ``Обзор``,
``Call of Duty`` и ``Лонг`` будет иметь значение по ключу ``tags``: ``~Обзор~Call of duty~Лонг~``.

Ключ ``created`` содержит дату публикации статьи в строковом формате.

.. note::
    Сервер сохраняет только перечисленные ключи и их значения.
    Все остальные ключи будут проигнорированы, а данные по ним будут утеряны.

api_like_article()
^^^^^^^^^^^^^^^^^^

Метод для переключения состояния лайка на статье.

.. code-block:: python

    @app.route('/article/like', methods=['POST'])
    def api_like_article()
    """
    :headers: 'user-id' - str(int)
              'article-id' - str(int)

    :returns: str(json) in format {'status': %JSON%}
    """

Заголовок ``user-id`` содержит *id* пользователя, который нажал кнопку лайка.
Заголовок ``article-id`` содержит *id* статьи, для которой пользователь нажал кнопку лайка.
Если на этой статье уже лайк от этого пользователя, то его лайк снимется.
Если на статье нет лайка от этого пользователя, то лайк будет поставлен.

api_add_comment()
^^^^^^^^^^^^^^^^^

Метод для добавления комметария к статье.

.. code-block:: python

    @app.route('/article/comments/add', methods=['POST'])
    def api_add_comment()
    '''
    :headers: 'user-id' - str(int)
              'article-id' - str(int)
              'root' - str(int)
              'text' - str

    :returns: str(json) in format {'status': %JSON%, 'comment-id': %INT%}
    '''

Заголовок ``user-id`` содержит *id* пользователя, которой написл комментарий. Заголовок ``article-id`` содержит *id*
статьи, к которой пишется комментарий. Заголовок ``root`` содержит *id* комментария, на который отвечает пользователь.
Если пользователь пишет комментрий к самой статье, то в заголовок ``root`` должно содержать значение ``-1``.
Заголовок ``text`` содержит в себе текст комментария.
api_like_comment()
^^^^^^^^^^^^^^^^^^

Метод для переключения состояния лайка на комментарии.

.. code-block:: python

    @app.route('/article/comments/like', methods=['POST'])
    def api_like_comment()
    """
    :headers: 'user-id' - str(int)
              'comment-id' - str(int)

    :returns: str(json) in format {'status': %JSON%}
    """

Заголовок ``user-id`` содержит *id* пользователя, который нажал кнопку лайка.
Заголовок ``comment-id`` содержит *id* комментария, для которой пользователь нажал кнопку лайка.
Если на этом комментарии уже лайк от этого пользователя, то его лайк снимется. Если на комментарии
нет лайка от этого пользователя, то лайк будет поставлен.

api_get_comments_likes()
^^^^^^^^^^^^^^^^^^^^^^^^

Метод для получения количества лайков на комментарии.

.. code-block:: python

    @app.route('/article/comments/like', methods=['GET'])
    def api_get_comments_likes():
    """
    :headers: 'comment-id' - str(int)

    :returns: str(json) in format {'status': %JSON%, 'likes-count': %INT%}
    """

Этот метод обрабатывает только один заголовок - *id* комментария,
для которой нужно узнать количество лайков.

api_get_pages()
^^^^^^^^^^^^^^^

Метод позволяет получить страницы с несколькими статьями на каждой.

.. code-block:: python

    @app.route('/pages', methods=['GET'])
    def api_get_pages()
    """
    :headers: 'user-id' - str(int)
              'indexes' - str(list)

    :returns: str(json) in format {'status': %JSON%, 'pages': %JSON%}
    """

Заголовок ``user-id`` содержит *id* пользователя, для которого запрашиваются страницы со статьями.
Если страницы запрашиваются для незалогиненного пользователя, то этот заголовок должен содержать значение ``-1``.
Заголовок ``indexes`` содержит список *id* запрашиваемых страниц перечисленных через символ ``~``.
Например, заголовок может содержать значение ``~1~2~3~``.
Возвращаемый ``JSON`` содержит ключ *pages*, который содержит запрашиваемые страницы со следующей структурой:

.. code-block:: python

    'REQUIRED_INDEX': [
        {
            'id': '%INT%'
            'preview_content': '%JSON%' # user-defined preview structure
            'name': '%STR%'
            'author_preview': {
                                'name': '%STR%'
                                'page': '%STR%'
                                'avatar': '%STR%'
                            }
            'answers': [
                            '%COMMENTID%': {
                                                'comment_text': '%STR%'
                                                'author_id': '%INT%'
                                                'likes_count': '%INT%'
                                                'id': '%INT%'
                                                'answers': '%LIST%'
                                        }
                        ]
            'likes_count': '%INT%'
            'comments_count': '%INT%'
            'tags': '%STR%'
            'created': '%STR%'
        },
        {
            'ANOTHER ARTICLE'
        },
        ...
    ],
    'ANOTHER_REQUIRED_INDEX': [
        {
            'ARTICLE'
        },
        {
            'ARTICLE'
        }
        ...
    ]

Ключ ``pages`` содержит список ключей, которые совпадаю с запрашиваемыми индексами страниц.
Значение по каждому ключу содержит список с контентом для предпоказа статьи.
Во возвращаемых страницах содержаться только незаблокированные у пользователя статьи.

Контент для предпоказа статьи содерждит следующие ключи:

Ключ ``id`` содержит *id* статьи

Ключ ``preview_content`` содержит *json* с контентом, который требуется для предпоказа в ленте.
Сервер никак не изменяет структуру и не обращается к ее содержимому.
Это позволяет определить структуру контента для предпоказа на строрне *frontend* и
изменять ее без необходимости вносить изменения на сервер.

Ключ ``name`` содержит название статьи.

Ключ ``author_preview`` содержит *json* с данными об авторе для предпоказа. Данные об авторе содержат *login*
пользователя, доступный по ключу ``name``, ссылку на страницу автора, доступную по ключу ``page`` и ссылку на аватар
автора, доступную по ключу ``avatar``.

Ключ ``answers`` содержит список коментариев и ответов к ним.
Этот список содержит древовиднусюб структуру комментариев.
В списке первого уровня лежат комментарии, которые пользователи написали к статье.
У каждого комментария есть список ответов, в котором содержаться комментарии с такой же структурой.
Для каждого комментария определены ключи ``comment_text``, который соджержит текст комментария, ``author_id``,
который содержит значение *id* автора комментария, ``likes_count``, котоырый содержит количество лайков
на комментарии, ``id``, который содержит *id* комментария и ``answers``, который содержит список ответов
на комментарий.

Ключ ``likes_count`` содержит количество лайков статьи. Ключ ``comments_count`` содержит количество комментариев статьи.

Ключ ``tags`` содержит теги статьи, перечисленные через разделитель ``~``. Напирмер, статья имеющая теги ``Обзор``,
``Call of Duty`` и ``Лонг`` будет иметьlikes_id значение по ключу ``tags``: ``~Обзор~Call of duty~Лонг~``.

Ключ ``created`` содержит дату публикации статьи в строковом формате.

.. note::
    Индексы страниц начинаются с ``0``.

api_add_user()
^^^^^^^^^^^^^^

Метод для регистрации нового пользователя.

.. code-block:: python

    @app.route('/users/new', methods=['POST'])
    def api_add_user()
    """
    :headers: 'user-info' - str(json) in format {'name': %STR%,
                                                 'password': %STR%,
                                                 'page': %STR%,
                                                 'avatar': %STR%,
                                                 'blocked_tags': %STR%}

    :returns: str(json) in format {'status': %JSON%, 'user-id': %INT%}
    """

Метод принимает только один заголовок с данными пользователя. Поля ``name`` и ``password`` заголовка являются
обязательными. Остальные поля опциональны. Метод возвращает *id* созданного пользователя.
Поля ``page`` и ``avatar`` являются ссылками на страницу пользователя и на его аватарку соответственно.
Поле ``blocked_tags`` является списком заблокированных тегов, разделенных символом ``~``.
Например, это поле может иметь значение ``~Рикролл~MMO~nsfw~``.

api_update_user_info()
^^^^^^^^^^^^^^^^^^^^^^

Метод, изменяющий пользовательские данные.

.. code-block:: python

    @app.route('/users/update', methods=['POST'])
    def api_update_user_info()
    """
    :headers: 'user-info' - str(json) in format {'page': %STR%,
                                                 'avatar': %STR%,
                                                 'blocked_tags': %STR%}

    :returns: str(json) in format {'status': %JSON%}
    """

Метод принимает только один заголовок с данными пользователя. Все поля заголовка являются опциональными.
Поля ``page`` и ``avatar`` являются ссылками на страницу пользователя и на его аватарку соответственно.
Поле ``blocked_tags`` является списком заблокированных тегов, разделенных символом ``~``.
Например, это поле может иметь значение ``~Рикролл~MMO~nsfw~``.

api_change_user_password()
^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод смены пользовательского пароля.

.. code-block:: python

    @app.route('/users/change_password', methods=['POST'])
    def api_change_user_password()
    """
    :headers: 'user-id' - str(int)
              'previous-password' - str
              'new-password' - str

    :returns: str(json) in format {'status': %JSON%}
    """

Заголовок ``user-id`` содержи *id* пользователя, который хочет сменить пароль. Заголовок ``previous-password``
содержит старый пароль пользователя. Если старый пароль будет указан неверно, то пароль не будет обновлен.
Заголовок ``new-password`` содержит новый пароль, который пользователь хочет установить.

api_check_user_password()
^^^^^^^^^^^^^^^^^^^^^^^^^

Метод для проверки пользовательского пароля.

.. code-block:: python

    @app.route('/users/check_password', methods=['GET'])
    def api_check_user_password()
    """
    :headers: 'user-id' - str(int)
              'password' - str

    :returns: str(json) in format {'status': %JSON%, 'is-correct': %BOOL%}
    """

Заголовок ``user-id`` содержит *id* пользователя, для которого происходит проверка пароля.
Заголовок ``password`` содержит пароль, которой нужно проверить.