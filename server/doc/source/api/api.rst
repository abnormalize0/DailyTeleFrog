Основные API методы
===================

Все методы API представлены в файле ``/server/src/api.py``.
Все API сетоды возвращают словарь, в котором содержится как минимум статус операции. Статус имеет следующую структуру:

.. code-block:: python

    {
        'type': 'OK' or 'Error'
        'error_type': 'OptionError' or 'ValueError'
        'message': '%STR%'
    }

Наличие поля ``type`` гарантируется. По значению этого поля можно определить завершился ли запрос на сервер успешно.
Если значение поля ``OK``, то запрос завершился корректно. В противном случае значение поля будет ``Error``.
Если запрос совершился с ошибкой, то все остальные поля кроме статуса будут содержать значение ``NONE``.
Остальные два поля являются опциональными. Оба поля присутствуют в словаре статуса только в том случае, если
запрос завершился с ошибкой. Поле ``error_type`` содержит в себе тип ошибки. Значение ``OptionError`` сигнализирует
о том, что в переданных параметрах была допущена ошибка, например было передано неверное название опции. Значение
``ValueError`` сигнализирует о том, у одно из параметров неверное значение, например для *id* пользователя имеет
значение ``-1``. Поле ``message`` содержит сообщение с подробным описанием возникшей проблемы.

api_article_post()
^^^^^^^^^^^^^^^^^^

Метод для опубликования статьи.

.. code-block:: python

    @app.route('/article', methods=['POST'])
    def api_article_post()
    """
    :headers: 'article' - str(json)
              'user-id' - str(int)

    :returns: str(json) in format {'status': %JSON%, 'article-id': %INT%}
    """

Заголовок ``article`` является *json* объектом в строковом формате, который представляет собой статью.

Статья обязана имееть следующую структуру:

.. code-block:: python

    {
        'article': '%JSON%' # user-defined article structure
        'preview_content': '%JSON%' # user-defined preview structure
        'name': '%STR%'
        'tags': '%STR%'
        'created': '%STR%'
    }

Ключ ``article`` содержит тело статьи со структурой определенной пользователем.
Сервер никак не изменяет статью, которую ему передали, и не обращается к ее содержимому.
Поэтому вся структура сохраняется в неизменном виде. Это позволяет определить структуру статьи на строрне *frontend* и
изменять ее без необходимости вносить изменения на сервер.

Ключ ``preview_content`` содержит *json* с контентом, который требуется для предпоказа в ленте.
Сервер никак не изменяет структуру и не обращается к ее содержимому.
Это позволяет определить структуру контента для предпоказа на строрне *frontend* и
изменять ее без необходимости вносить изменения на сервер.

Ключ ``name`` содержит название статьи.

Ключ ``tags`` содержит теги статьи, перечисленные через разделитель ``~``. Напирмер, статья имеющая теги ``Обзор``,
``Call of Duty`` и ``Лонг`` будет иметь значение по ключу ``tags``: ``~Обзор~Call of duty~Лонг~``.

Ключ ``created`` содержит дату публикации статьи в строковом формате.

.. note::
    Сервер сохраняет только перечисленные ключи и их значения.
    Все остальные ключи будут проигнорированы, а данные по ним будут утеряны.

api_article_get()
^^^^^^^^^^^^^^^^^

Метод для получения статьи.

.. code-block:: python

    @app.route('/article', methods=['GET'])
    def api_article_get()
    """
    :headers: 'article-id' - str(int)

    :returns: str(json) in format {'status': %JSON%, 'article': %JSON%}
    """

Этот метод обрабатывает только один заголовок - *id* статьи, которую нужно вернуть.
Метод читает все необходимые данные о статье с требуемым *id* и возвращает статью в формате *json*.
Статья имеет следующую структуру:

.. code-block:: python

    {
        'article': '%JSON%' # user-defined article structure
        'preview_content': '%JSON%' # user-defined preview structure
        'name': '%STR%'
        'author_preview': {
                            'name': '%STR%'
                            'page': '%STR%'
                            'avatar': '%STR%'
                          }
        'answers': [
                        '%COMMENT_ID%': {
                                            'comment_text': '%STR%'
                                            'author_id': '%INT%'
                                            'likes_count': '%INT%'
                                            'id': '%INT%'
                                            'answers': '%LIST%'
                        },
                        'ANOTHER_COMMENT_ID': {
                        },
                        ...
                    ]
        'likes_count': '%INT%'
        'likes_id': '%STR%'
        'comments_count': '%INT%'
        'tags': '%STR%'
        'created': '%STR%'
    }

Ключ ``article`` содержит тело статьи со структурой определенной пользователем.
Сервер никак не изменяет статью, которую ему передали, и не обращается к ее содержимому.
Поэтому вся структура сохраняется в неизменном виде. Это позволяет определить структуру статьи на строрне *frontend* и
изменять ее без необходимости вносить изменения на сервер.

Ключ ``preview_content`` содержит *json* с контентом, который требуется для предпоказа в ленте.
Сервер никак не изменяет структуру и не обращается к ее содержимому.
Это позволяет определить структуру контента для предпоказа на строрне *frontend* и
изменять ее без необходимости вносить изменения на сервер.

Ключ ``name`` содержит название статьи.

Ключ ``author_preview`` содержит *json* с данными об авторе для предпоказа. Данные об авторе содержат *login*
пользователя, доступный по ключу ``name``, ссылку на страницу автора, доступную по ключу ``page`` и ссылку на аватар
автора, доступную по ключу ``avatar``.

Ключ ``answers`` содержит список коментариев и ответов к ним.
Этот список содержит древовиднусюб структуру комментариев.
В списке первого уровня лежат комментарии, которые пользователи написали к статье.
У каждого комментария есть список ответов, в котором содержаться комментарии с такой же структурой.
Для каждого комментария определены ключи ``comment_text``, который соджержит текст комментария, ``author_id``,
который содержит значение *id* автора комментария, ``likes_count``, котоырый содержит количество лайков
на комментарии, ``id``, который содержит *id* комментария и ``answers``, который содержит список ответов
на комментарий.

Ключ ``likes_count`` содержит количество лайков статьи. Ключ ``comments_count`` содержит количество комментариев статьи.

Ключ ``likes_id`` содержит *id* пользователей, который лайкнули статью, перечисленные через разделитель ``~``.
Напирмер, статья имеющая лайки от пользователей с *id* ``1`` и ``2`` будет иметь значение по ключу ``likes_id``:
``~1~~2~``.

Ключ ``tags`` содержит теги статьи, перечисленные через разделитель ``~``. Напирмер, статья имеющая теги ``Обзор``,
``Call of Duty`` и ``Лонг`` будет иметь значение по ключу ``tags``: ``~Обзор~~Call of duty~~Лонг~``.

Ключ ``created`` содержит дату публикации статьи в строковом формате.

api_article_likes_post()
^^^^^^^^^^^^^^^^^^^^^^^^

Метод для переключения состояния лайка на статье.

.. code-block:: python

    @app.route('/article/like', methods=['POST'])
    def api_article_likes_post()
    """
    :headers: 'user-id' - str(int)
              'article-id' - str(int)

    :returns: str(json) in format {'status': %JSON%}
    """

Заголовок ``user-id`` содержит *id* пользователя, который нажал кнопку лайка.
Заголовок ``article-id`` содержит *id* статьи, для которой пользователь нажал кнопку лайка.
Если на этой статье уже лайк от этого пользователя, то его лайк снимется.
Если на статье нет лайка от этого пользователя, то лайк будет поставлен.

api_article_likes_get()
^^^^^^^^^^^^^^^^^^^^^^^

Метод для получения количества лайков у статьи.

.. code-block:: python

    @app.route('/article/likes', methods=['GET'])
    def api_article_likes_get()
    """
    :headers: 'article-id' - str(int)

    :returns: str(json) in format {'status': %JSON%, 'likes-count': %INT%}
    """

Этот метод обрабатывает только один заголовок - *id* статьи,
для которой нужно узнать количество лайков.

api_article_dislikes_post()
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод для переключения состояния дизлайка на статье.

.. code-block:: python

    @app.route('/article/dislike', methods=['POST'])
    def api_article_dislikes_post()
    """
    :headers: 'user-id' - str(int)
              'article-id' - str(int)

    :returns: str(json) in format {'status': %JSON%}
    """

Заголовок ``user-id`` содержит *id* пользователя, который нажал кнопку дизлайка.
Заголовок ``article-id`` содержит *id* статьи, для которой пользователь нажал кнопку дизлайка.
Если на этой статье уже лайк от этого пользователя, то его лайк снимется.
Если на статье нет дизлайка от этого пользователя, то лайк будет поставлен.

api_article_dislikes_get()
^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод для получения количества лайков у статьи.

.. code-block:: python

    @app.route('/article/dislikes', methods=['GET'])
    def api_article_dislikes_get()
    """
    :headers: 'article-id' - str(int)

    :returns: str(json) in format {'status': %JSON%, 'dislikes-count': %INT%}
    """

Этот метод обрабатывает только один заголовок - *id* статьи,
для которой нужно узнать количество дизлайков.

api_article_comments_post()
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод для добавления комметария к статье.

.. code-block:: python

    @app.route('/article/comments', methods=['POST'])
    def api_article_comments_post()
    '''
    :headers: 'user-id' - str(int)
              'article-id' - str(int)
              'root' - str(int)
              'text' - str

    :returns: str(json) in format {'status': %JSON%, 'comment-id': %INT%}
    '''

Заголовок ``user-id`` содержит *id* пользователя, которой написл комментарий. Заголовок ``article-id`` содержит *id*
статьи, к которой пишется комментарий. Заголовок ``root`` содержит *id* комментария, на который отвечает пользователь.
Если пользователь пишет комментрий к самой статье, то в заголовок ``root`` должно содержать значение ``-1``.
Заголовок ``text`` содержит в себе текст комментария.

api_article_comments_get()
^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод для получения количества комментариев у статьи.

.. code-block:: python

    @app.route('/article/comments', methods=['GET'])
    def api_article_comments_get()
    """
    :headers: 'article-id' - str(int)

    :returns: str(json) in format {'status': %JSON%, 'comments-count': %INT%}
    """

Этот метод обрабатывает только один заголовок - *id* статьи,
для которой нужно узнать количество комментариев.

api_article_comments_like_post()
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод для переключения состояния лайка на комментарии.

.. code-block:: python

    @app.route('/article/comments/like', methods=['POST'])
    def api_article_comments_like_post()
    """
    :headers: 'user-id' - str(int)
              'comment-id' - str(int)

    :returns: str(json) in format {'status': %JSON%}
    """

Заголовок ``user-id`` содержит *id* пользователя, который нажал кнопку лайка.
Заголовок ``comment-id`` содержит *id* комментария, для которой пользователь нажал кнопку лайка.
Если на этом комментарии уже лайк от этого пользователя, то его лайк снимется. Если на комментарии
нет лайка от этого пользователя, то лайк будет поставлен.

api_article_comments_like_get()
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод для получения количества лайков на комментарии.

.. code-block:: python

    @app.route('/article/comments/like', methods=['GET'])
    def api_article_comments_like_get():
    """
    :headers: 'comment-id' - str(int)

    :returns: str(json) in format {'status': %JSON%, 'likes-count': %INT%}
    """

Этот метод обрабатывает только один заголовок - *id* комментария,
для которой нужно узнать количество лайков.

api_article_comments_dislike_post()
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод для переключения состояния дизлайка на комментарии.

.. code-block:: python

    @app.route('/article/comments/dislike', methods=['POST'])
    def api_article_comments_dislike_post()
    """
    :headers: 'user-id' - str(int)
              'comment-id' - str(int)

    :returns: str(json) in format {'status': %JSON%}
    """

Заголовок ``user-id`` содержит *id* пользователя, который нажал кнопку дизлайка.
Заголовок ``comment-id`` содержит *id* комментария, для которой пользователь нажал кнопку дизлайка.
Если на этом комментарии уже лайк от этого пользователя, то его лайк снимется. Если на комментарии
нет дизлайка от этого пользователя, то лайк будет поставлен.

api_article_comments_dislike_get()
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод для получения количества дизлайков на комментарии.

.. code-block:: python

    @app.route('/article/comments/dislike', methods=['GET'])
    def api_article_comments_dislike_get():
    """
    :headers: 'comment-id' - str(int)

    :returns: str(json) in format {'status': %JSON%, 'dislikes-count': %INT%}
    """

Этот метод обрабатывает только один заголовок - *id* комментария,
для которой нужно узнать количество дизлайков.

api_get_pages()
^^^^^^^^^^^^^^^

Метод позволяет получить страницы с несколькими статьями на каждой.

.. code-block:: python

    @app.route('/pages', methods=['GET'])
    def api_get_pages()
    """
    :headers: 'user-id' - str(int)
              'indexes' - str(list)

    :returns: str(json) in format {'status': %JSON%, 'pages': %JSON%}
    """

Заголовок ``user-id`` содержит *id* пользователя, для которого запрашиваются страницы со статьями.
Если страницы запрашиваются для незалогиненного пользователя, то этот заголовок должен содержать значение ``-1``.
Заголовок ``indexes`` содержит список *id* запрашиваемых страниц перечисленных через символ ``~``.
Например, заголовок может содержать значение ``~1~2~3~``.
Возвращаемый ``JSON`` содержит ключ *pages*, который содержит запрашиваемые страницы со следующей структурой:

.. code-block:: python

    'REQUIRED_INDEX': [
        {
            'id': '%INT%'
            'preview_content': '%JSON%' # user-defined preview structure
            'name': '%STR%'
            'author_preview': {
                                'name': '%STR%'
                                'page': '%STR%'
                                'avatar': '%STR%'
                            }
            'answers': [
                            '%COMMENTID%': {
                                                'comment_text': '%STR%'
                                                'author_id': '%INT%'
                                                'likes_count': '%INT%'
                                                'id': '%INT%'
                                                'answers': '%LIST%'
                                        }
                        ]
            'likes_count': '%INT%'
            'comments_count': '%INT%'
            'tags': '%STR%'
            'created': '%STR%'
        },
        {
            'ANOTHER ARTICLE'
        },
        ...
    ],
    'ANOTHER_REQUIRED_INDEX': [
        {
            'ARTICLE'
        },
        {
            'ARTICLE'
        }
        ...
    ]

Ключ ``pages`` содержит список ключей, которые совпадаю с запрашиваемыми индексами страниц.
Значение по каждому ключу содержит список с контентом для предпоказа статьи.
Во возвращаемых страницах содержаться только незаблокированные у пользователя статьи.

Контент для предпоказа статьи содерждит следующие ключи:

Ключ ``id`` содержит *id* статьи

Ключ ``preview_content`` содержит *json* с контентом, который требуется для предпоказа в ленте.
Сервер никак не изменяет структуру и не обращается к ее содержимому.
Это позволяет определить структуру контента для предпоказа на строрне *frontend* и
изменять ее без необходимости вносить изменения на сервер.

Ключ ``name`` содержит название статьи.

Ключ ``author_preview`` содержит *json* с данными об авторе для предпоказа. Данные об авторе содержат *login*
пользователя, доступный по ключу ``name``, ссылку на страницу автора, доступную по ключу ``page`` и ссылку на аватар
автора, доступную по ключу ``avatar``.

Ключ ``answers`` содержит список коментариев и ответов к ним.
Этот список содержит древовиднусюб структуру комментариев.
В списке первого уровня лежат комментарии, которые пользователи написали к статье.
У каждого комментария есть список ответов, в котором содержаться комментарии с такой же структурой.
Для каждого комментария определены ключи ``comment_text``, который соджержит текст комментария, ``author_id``,
который содержит значение *id* автора комментария, ``likes_count``, котоырый содержит количество лайков
на комментарии, ``id``, который содержит *id* комментария и ``answers``, который содержит список ответов
на комментарий.

Ключ ``likes_count`` содержит количество лайков статьи. Ключ ``comments_count`` содержит количество комментариев статьи.

Ключ ``tags`` содержит теги статьи, перечисленные через разделитель ``~``. Напирмер, статья имеющая теги ``Обзор``,
``Call of Duty`` и ``Лонг`` будет иметьlikes_id значение по ключу ``tags``: ``~Обзор~Call of duty~Лонг~``.

Ключ ``created`` содержит дату публикации статьи в строковом формате.

.. note::
    Индексы страниц начинаются с ``0``.

api_users_post()
^^^^^^^^^^^^^^^^

Метод для регистрации нового пользователя.

.. code-block:: python

    @app.route('/users', methods=['POST'])
    def api_users_post()
    """
    :headers: 'user-info' - str(json) in format {'name': %STR%,
                                                 'password': %STR%,
                                                 'page': %STR%,
                                                 'avatar': %STR%,
                                                 'blocked_tags': %STR%}

    :returns: str(json) in format {'status': %JSON%, 'user-id': %INT%}
    """

Метод принимает только один заголовок с данными пользователя. Поля ``name`` и ``password`` заголовка являются
обязательными. Остальные поля опциональны. Метод возвращает *id* созданного пользователя.
Поля ``page`` и ``avatar`` являются ссылками на страницу пользователя и на его аватарку соответственно.
Поле ``blocked_tags`` является списком заблокированных тегов, разделенных символом ``~``.
Например, это поле может иметь значение ``~Рикролл~MMO~nsfw~``.

api_users_profile_get()
^^^^^^^^^^^^^^^^^^^^^^^

Метод, позволяющий получить всю информацию о пользователе, необходимую для отображения страницы профиля.

.. code-block:: python

    @app.route('/users/profile', methods=['GET'])
    def api_users_profile_get()
    """
    :headers: 'user-id' - str(int)
    :returns: str(json) in format {'status': %JSON%, 'profile': %JSON%}
    """

Заголовок ``user-id`` содержит *id* пользователя, для которого запрашивается информация о профиле.
Объект ``json``, доступный по ключу *profile* имеет следующую структуру:

.. code-block:: python

    'profile': {
        'user_id': '%INT%',
        'name': '%STR%',
        'password': '%STR%',
        'page': '%STR%',
        'avatar': '%STR%',
        'blocked_tags': '%STR%'
    }

api_users_update_post()
^^^^^^^^^^^^^^^^^^^^^^^

Метод, изменяющий пользовательские данные.

.. code-block:: python

    @app.route('/users/update', methods=['POST'])
    def api_users_update_post()
    """
    :headers: 'user-info' - str(json) in format {'page': %STR%,
                                                 'avatar': %STR%,
                                                 'blocked_tags': %STR%}

    :returns: str(json) in format {'status': %JSON%}
    """

Метод принимает только один заголовок с данными пользователя. Все поля заголовка являются опциональными.
Поля ``page`` и ``avatar`` являются ссылками на страницу пользователя и на его аватарку соответственно.
Поле ``blocked_tags`` является списком заблокированных тегов, разделенных символом ``~``.
Например, это поле может иметь значение ``~Рикролл~MMO~nsfw~``.

api_users_password_post()
^^^^^^^^^^^^^^^^^^^^^^^^^

Метод смены пользовательского пароля.

.. code-block:: python

    @app.route('/users/password', methods=['POST'])
    def api_users_password_post()
    """
    :headers: 'user-id' - str(int)
              'previous-password' - str
              'new-password' - str

    :returns: str(json) in format {'status': %JSON%}
    """

Заголовок ``user-id`` содержит *id* пользователя, который хочет сменить пароль. Заголовок ``previous-password``
содержит старый пароль пользователя. Если старый пароль будет указан неверно, то пароль не будет обновлен.
Заголовок ``new-password`` содержит новый пароль, который пользователь хочет установить.

api_users_password_check_get()
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод для проверки пользовательского пароля.

.. code-block:: python

    @app.route('/users/password/check', methods=['GET'])
    def api_users_password_check_get()
    """
    :headers: 'user-id' - str(int)
              'password' - str

    :returns: str(json) in format {'status': %JSON%, 'is-correct': %BOOL%}
    """

Заголовок ``user-id`` содержит *id* пользователя, для которого происходит проверка пароля.
Заголовок ``password`` содержит пароль, которой нужно проверить.